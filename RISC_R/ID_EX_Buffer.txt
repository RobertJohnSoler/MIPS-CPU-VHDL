library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity ID_EX_Buffer is
    Port (ID_WB : in STD_LOGIC;
          ID_M : in std_logic;
          ID_EX : in std_logic_vector (6 downto 0);
          ID_PC : in std_logic_vector (31 downto 0);
          ID_data1 : in std_logic_vector (31 downto 0);
          ID_data2 : in std_logic_vector (31 downto 0);
          ID_signExtend : in std_logic_vector (31 downto 0);
          ID_instruction1 : in std_logic_vector (4 downto 0);
          ID_instruction2 : in std_logic_vector (4 downto 0);
          clk : in std_logic;
          EX_WB : out STD_LOGIC;
          EX_M : out std_logic;
          EX_EX : out std_logic_vector (6 downto 0);
          EX_PC : out std_logic_vector (31 downto 0);
          EX_data1 : out std_logic_vector (31 downto 0);
          EX_data2 : out std_logic_vector (31 downto 0);
          EX_signExtend : out std_logic_vector (31 downto 0);
          EX_instruction1 : out std_logic_vector (4 downto 0);
          EX_instruction2 : out std_logic_vector (4 downto 0)
          );
end ID_EX_Buffer;

architecture Behavioral of ID_EX_Buffer is
begin
    storage: process is
    variable PC, data1, data2, signExtend : std_logic_vector(31 downto 0);
    variable WB, M : std_logic;
    variable EX : std_logic_vector(6 downto 0);
    variable inst1, inst2 : std_logic_vector (4 downto 0); 
    begin
        wait until rising_edge(clk);
            WB := ID_WB;
            M := ID_M;
            EX := ID_EX;
            PC := ID_PC;
            data1 := ID_data1;
            data2 := ID_data2;
            signExtend := ID_signExtend;
            inst1 := ID_instruction1;
            inst2 := ID_instruction2;
        EX_WB <= WB;
        EX_M <= M;
        EX_EX <= EX;
        EX_PC <= PC;
        EX_data1 <= data1;
        EX_data2 <= data2;
        EX_signExtend <= signExtend;
        EX_instruction1 <= inst1;
        EX_instruction2 <= inst2;
    end process storage;
    
end Behavioral;
